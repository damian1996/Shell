1) kompiluj z -g (już pewnie to robisz)
2) valgrind --tool=callgrind ./mshell < in > out
3) kcachegrind
w razie czego doinstaluj, jest to w repo
4) ciesz oczy kolorowymi prostokącikami xdd

./clean.sh
./prepare.sh
./run_suite.sh ../mshell 1
./run_suite.sh ../mshell 3
./run_suite.sh ../mshell 2
./run_suite.sh ../mshell 1

ok, więc jak już mówiłam read(MAX_LINE) wczytuje ci maksymalnie MAX_LINE i może ci poszatkować
cały pilk na kawałeczki dowolnie, więc co robiszv
w pętli:
- trzymasz sobie początek danej komendy
- wczytujesz ile się da
(i tu mam to znowu w pętli ale to raczej kwestia implementacji)
- patrzysz czy wczytałeś jakiś \n (w tym przedziale co właśnie wczytałeś)
- jeżeli tak to gratulacje, wczytałeś komendę, wykonujesz ją i przesuwasz wskaźniki (zauważ że mogłeś wczytać
parę komend na raz, dlatego ja miałam tam pętlę i teraz do niej wracam i znowu szukam \n)
- jeżeli nie ma \n to znaczy:
* jeszcze nie wczytałeś całej komendy, ustawiasz wskaźniczki i break z tej pętli, jedziemy dalej i wczytujemy
* jeszcze nie wczytałeś całej komendy, ale brakło ci bufora, więc go przesuwasz na początek, break z tej pętli
 i wczytujesz dalej
 * ojej, ktoś dał większą linijkę niż można (bufor w którym aktualnie trzymasz komendę zaczyna się od początku
  aż do końca)
czyli praktycznie napisałam ci jak wygląda mój kod…

czyli read wczytuje jak mu sie podoba? ;_; co rozumiesz poprzez "wczytujesz ile sie da"?
bo to jest chyba kwestia, ktorej najbardziej nie rozumiem..
tego jak dziala ten cholerny read, w jaki sposob sposob wybiera dane ktore wczytuje

read wczytuje ile mu się podoba, ale nie więcej niż ilość, którą mu podałeś w argumencie
i "ile się da" to mam na myśli właśnie że podajesz mu ile bufora Ci zostało


Etap 2. - wejście z pliku

Zmiany w stosunku do Etapu 1:
<------>1. Wypisujemy prompt na STDOUT tylko jeśli STDIN odpowiada specjalnemu urządzeniu znakowemu (man fstat).
<------>2. Wczytując linię z STDIN musimy się liczyć z tym że zostanie wczytanych wiele linii, oraz z tym że ostatnia z nich może nie być wczytana w całości. Należy uwzględnić przypadek że w jednym odczyc
<------>3. Wciąż wystarczy wykonywać tylko pierwszą z komend z każdej z wczytanych linii.
<------>4. Proszę pamiętać że ostania linia wejścia może się zakończyć końcem pliku a nie końcem linii.

tar zxvf test1.tar.gz -C /C02/Cwiczenia/SO/jkozik/tcs/common/matinf.uj.edu.pl/afs/home/z1121978//afs/profil_TCS/Desktop/shell
/home/z1121978//afs/profil_TCS/Desktop/shell
./run_all.sh ~/afs/profil_TCS/Desktop/shell/mshell /tmp/Test1

Testy (należy uruchamiać w systemie Minix zainstalowanym zgodnie z instrukcją z ćwiczeń):
1. Rozpakuj test1.tar.gz.
2. Przed rozpoczęciem testów w rozpakowanym katalogu test1 uruchom.
<------>./prepare.sh /tmp/Test1
<------>(
<------>na Linux'ie warto też przegenerować odpowiedzi
<------><------>./gen_all.sh /bin/bash /tmp/Test1.
<------>)
3. Po zakończeniu testów test1 uruchom
<------>./clean.sh /tmp/Test1
4. Do uruchomienia wszystkich testów służy run_all.sh. Przykładowe wywołanie
<------>./run_all.sh ~/shell/mshell /tmp/Test1
5. Każdy test jest wywoływany w dwóch trybach.
<------>- W trybie "raw" na wejście podawany jest po prostu plik. Przykładowe wywołanie testu 4
<------><------>./run_one_raw.sh ~/shell/mshell /tmp/Test1 4
<------>- W trybie "splitter" wejście jest podawane programowi splitter i przekazywane przez pipe do shella. Splitter przepisuje wejście na wyjście robiąc przerwy w pseudolosowych momentach. Przykładowe w
<------><------>./run_one_splitter.sh ~/shell/mshell /tmp/Test1 2
