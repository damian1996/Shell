patrze na te kolejne komendy w pipelinie... i wykonuje pierwszÄ…..
i robie to samo co wczesniej? przekazuje do pipe'a itd?
i dlaczego jest jest builtinsem to nie przepinam pipe'Ã³w?
i na co ja tu mam czekaÄ‡? ._.
 jak takie cos moze zrozumiec samemu.. to jest jakas totalna abstrakcja ;_;

1) tak 2) masz zaÅ‚oÅ¼enie Å¼e builtins nie moÅ¼e znaleÅºÄ‡ siÄ™ w pipeline,
 Å¼ebyÅ› mÃ³gÅ‚ mu przepiÄ…Ä‡ pipe'y bez szkody dla mshella to musiaÅ‚byÅ›
 zrobiÄ‡ mu nowy proces specjalnie (paskudne)
 albo jakoÅ› specjalnie kommbinowaÄ‡ (nie chcesz tego)
3) czekasz na to aÅ¼ counter dzieci spadnie do zera,
 za kaÅ¼dym razem jak Å‚apiesz sigchilda i w handlerze od niego
  przekrÄ™ci siÄ™ waitpid
	 (bo tam w tym sigchild handlerze dajesz waitpida nieblokujÄ…cego
	  w pÄ™tli dopÃ³ki coÅ› Å‚apie) to --counter
a zrozumiaÅ‚am sama, wiÄ™c to da siÄ™ zrobiÄ‡ ğŸ˜›

sprawdzasz czy pipeline ma 0 / 1 komendÄ™, przygotowujesz na
poczÄ…tku pipe'y, bierzesz pierwszÄ… komendÄ™,
jakÄ…Å› fikuÅ›nÄ… funkcjÄ™ command, ktÃ³ra sprawdza czy to builtin,
 jeÅ¼eli tak wykonuje go i wraca, jeÅ¼eli nie to siÄ™ forkuje
- w dziecku przestawia pipe'y, redirections,
 odczepia proces od terminala
(to pÃ³Åºniej zaklepiesz, mÃ³wiÄ™ na przyszÅ‚oÅ›Ä‡) odpala execa
- w rodzicu zlicza counter odpalonych procesÃ³w
po wyjÅ›ciu z funkcji przestawia pipe'y

jak juÅ¼ wykonasz wszystkie komendy to czekasz na dzieci sigsuspendem

Odpalam procesy po kolei
Na koÅ„cu pipelina musze poczekac az wszystkie sie zakoncza
Czekanie na sigchilda
counter - liczba odpaonych dzieci
sigset_t / sigsuspend

Przed kolenym pipelinem blokuje SIGCHILD
z uzyciem sigprocmask(SIG_BLOCK, , NULL)
sigset trzyma maske o procesach
sigemptyset czysci maske
sigint_handler, sigchild_handler
set_handlers z wykladu

volatile - to moÅ¼e byÄ‡Â wykorzystane w handlerze, moze sie zmieniac - ma nic nie zmieniac
Zapisuje w kolejce informacje o backroundzie

Etap 4. - przekierowanie we/wy i Å‚Ä…czenie komend pipe'ami.

	1. KaÅ¼dy progam uruchamiany z shella moÅ¼e mieÄ‡ przekierowane wejÅ›cie i wyjÅ›cie. Przekierowania dla wbudowanych poleceÅ„ shella moÅ¼na ignorowaÄ‡.
	Tablica 'redirs' w strukturze 'command' zawiera przekierowania zdefiniowane dla danej komendy. Tablica jest zakoÅ„czona NULL'em.

	- Przekierowanie wejÅ›cia: jeÅ¼eli pole 'flags' w w strukturze 'redirection' speÅ‚nia makro 'IS_RIN(x)' to nowo uruchomiony program
	powinien mieÄ‡ otwarty plik o nazwie wskazanej przez pole 'filename' na standardowym wejÅ›ciu (deskryptor 0).

	- Przekierowanie wyjÅ›cia: jeÅ¼eli pole 'flags' w w strukturze 'redirection' speÅ‚nia makro 'IS_ROUT(x)' lub 'IS_RAPPEND(x)'
	to nowo uruchomiony program powinien mieÄ‡ otwarty plik o nazwie wskazanej przez pole 'filename' na standardowym wyjÅ›ciu (deskryptor 1).
	Dodatkowo jeÅ›li flagi speÅ‚niajÄ… makro 'IS_RAPPEND(x)' to plik powinien zostaÄ‡ otwarty w trybie dopisywania (O_APPEND),
	 w przeciwnym przypadku zawartoÅ›Ä‡ pliku powinna zostaÄ‡ wyczyszczona (O_TRUNC).
  W przypadku gdy plik do ktÃ³rego przekierowane jest wyjÅ›cie nie istnieje, powinien zostaÄ‡ stworzony.

	NaleÅ¼y obsÅ‚uÅ¼yÄ‡ nastÄ™pujÄ…ce bÅ‚Ä™dy:
	- plik nie istnieje -> wypisz na stderr: '(nazwa pliku): no such file or directory\n',
	- brak odpowiednich praw dostÄ™pu ->  wypisz na stderr: '(nazwa pliku):  permission denied\n'.

	MoÅ¼na przyjÄ…Ä‡ Å¼e lista przekierowaÅ„ dla kaÅ¼dej komendy zawiera co najwyÅ¼ej jedno przekierowanie wejÅ›cia i co najwyÅ¼ej jedno przekierowanie wyjÅ›cia.

	2. Polecenia w jednej linii mogÄ… byÄ‡ poÅ‚Ä…czone pipe'ami '|'. CiÄ…g takich komend bÄ™dziemy nazywaÄ‡ pipeline.
	   W przypadku gdy pipeline zawiera wiÄ™cej niÅ¼ jedno polecenie moÅ¼na zaÅ‚oÅ¼yÄ‡ Å¼e Å¼adne z nich nie jest komendÄ… wbudowanÄ… shella.
	   NaleÅ¼y wykonaÄ‡ wszystkie polecenia pipeline'a, kaÅ¼de w osobnym procesie potomnym shella.
		 Kolejne polecenia powinny byÄ‡ poÅ‚Ä…czone pipe'ami tak aby wyjÅ›cie procesu realizujÄ…cego polecenie k trafiaÅ‚o na wejÅ›cie procesu polecenia k+1.
		 Shell powinien zawiesiÄ‡ swoje dziaÅ‚anie do momentu aÅ¼ wszystkie procesy realizujÄ…ce polecenia pipeline'a siÄ™ zakoÅ„czÄ….
		 JeÅ›li polecenie ma zdefiniowane przekierowanie(a) we/wy to majÄ… one pierwszeÅ„stwo przed pipe'ami.

	3. W jednej linii moÅ¼ne byÄ‡ zdefiniowanych wiele pipeline'Ã³w oddzielonych znakiem ';'.
	 NaleÅ¼y je wykonaÄ‡ sekwencyjnie tzn. wykonaÄ‡ pierwszy poczekaÄ‡ aÅ¼ wszystkie procesy siÄ™ zakoÅ„czÄ… i dopiero wtedy wykonaÄ‡ drugi itd.

Uwaga! Parser akceptuje linie w ktÃ³rych znajdujÄ… siÄ™ puste komendy.
 W szczegÃ³lnoÅ›ci linia zawierajÄ…ca "ls | sort ; ls |  | wc" zostanie poprawnie sparsowana.
  Druga komenda drugiego pipeline'a bÄ™dzie miaÅ‚a argv[0]==NULL.
	JeÅ›li w linii wystÄ™puje pipeline o dÅ‚ugoÅ›ci przynajmniej 2 zawierajÄ…cy pustÄ… komendÄ™ to naleÅ¼y takÄ… liniÄ™ w caÅ‚oÅ›ci zignorowaÄ‡ i ogÅ‚osiÄ‡ syntax error.

Syscall checklist: open, close, pipe, dup/dup2/fcntl

PrzykÅ‚ad sesji (porÃ³wnaj wyniki z tym co robi np. bash):
$ ls > a
$ ls >> a
$ ls >> b
$ cat < a
$ cat < a > b
$ cat < a >> b
$ ls | sort
...
$ ls | cat | sort | wc
...
$ ls > /dev/null | wc
      0       0       0
$ ls | wc < /dev/null
      0       0       0
$ ls | sleep 10 | ls | sort # shel powinien siÄ™ zawiesiÄ‡ na 10s.
...
$ ls /etc | grep "a" > a ; ls /home | sort > b
...
$ sleep 5 ; sleep 5; sleep 5; echo "yawn" # wykonanie powinna trwac 15s.
yawn




dobra, zacznijmy moze od jeszcze bardziej prymitywnego pytania... a wlasciwie od poczatku...
jak mam arg1 | arg2 | arg3..
to najpierw jako line->pipelines[iterPipe]->pipeline[iPipe] dostaje to arg1, tak?

taak
i teraz .. w jaki sposob robie tego pipe'a? tworze sobie jakas tablice int fd[2]
i robie po prostu pipe(fd), tak?
czy musze to jakos skorzystac z tej komendy?

tak
robisz po prostu pipe(fd)
i to mi tworzy jednego pipe'a, tak? w ten sposob : arg1 |

noâ€¦ powiedzmyâ€¦
i skad on wie, ze czyta z arg1 do jakiegos tam arg2?

nie wie
Å¼eby wiedziaÅ‚:
robisz forka
dziecko jest twoim arg1
"powiedzmy"
i teraz to dziecko sobie musi przestawiÄ‡ stdout na pipe'a
dup2â€¦
konkretniej
pipe(fd) wypeÅ‚ni ci tablicÄ™ fd filedescriptorami od pipe'a
na fd[0] bÄ™dziesz chciaÅ‚ czytaÄ‡, na fd[1] bÄ™dziesz chciaÅ‚ pisaÄ‡
czyli dziecko jeÅ¼eli chce pisaÄ‡ na pipe'a
to zamienia sobie stdout (1) na fd[1]
o tak: dup2(fd[1], 1)
na marginesie: a fd[0] zamknie - nie jest mu potrzebne, bo nie bÄ™dzie jednoczeÅ›nie pisaÅ‚
i czytaÅ‚ z tego samego pipe'a
i po tym dup2 jeÅ¼eli zrobisz zwykÅ‚ego printfa, czy, w naszym przypadku,
execa to bÄ™dzie pisaÅ‚ na pipe'a
na koÅ„cu nie zapomnij wyjÅ›Ä‡ z dziecka
exitem

jeszcze jednoâ€¦ w rodzicu musisz teÅ¼ zadbaÄ‡ o zamykanie pipe'a
bo dÅ‚ugo mi siÄ™ przez to wieszaÅ‚o ğŸ˜›
konkretniej (pozostajemy przy naszym przykÅ‚adzie Å¼e ustawiamy pipe'a tylko po to Å¼eby dziecko
 do niego coÅ› pisaÅ‚o)
zamykamy fd[1] (bo dziecko do niego pisze, nie rodzic)


i teraz dziecko skoÅ„czyÅ‚o pisaÄ‡, zamknÄ™Å‚o siÄ™
rodzic czekaÅ‚ waitpidem na niego
i teraz rodzic musi teÅ¼ zamknÄ…Ä‡ drugi koniec pipe'a (fd[0])
czekajâ€¦
?

no nie, akurat tego koÅ„ca nie zamyka, sorryâ€¦
bo teraz to zrobi siÄ™ tak
Å¼e odpalisz nastÄ™pne dziecko
ono siÄ™ przyczepi do tego pipe'a na fd[0] i  czytaÄ‡
i dopiero wtedy jak to dziecko skoÅ„czy
rodzic zamknie pipe'a
i wtedy zamknie oba koÅ„ce i to bÄ™dzie koniec tego pipe'a
w sumie to zamknie zaraz po forkuâ€¦
jup
bo teraz bÄ™dzie to wszystko w pÄ™tli i bÄ™dziesz sobie tymi pipe'ami "Å¼onglowaÅ‚"
tak sobie je podmieniaÅ‚



okâ€¦ wiÄ™c pipe ma dwa koÅ„ce
z jednego czytasz, do drugiego piszesz
i jak robisz forka
to teraz masz i w dzecku i w rodzicu otwarte oba koÅ„ce
maÅ‚o tego bÄ™dziesz miaÅ‚ potem po dwa pipe'y
w sumie 4â€¦
dla rodzica i dla dzieckaâ€¦
ok, najpierw popatrzmy na dziecko
i narysujÄ™ sytuacjÄ™â€¦
| pipe1 | -----> (dziecko ) -----> | pipe2 |
no i dziecko sobie uÅ¼ywa dwÃ³ch koÅ„cÃ³w
pozostaÅ‚e dwa moÅ¼emy zamknÄ…Ä‡
no i dziecko sobie jeszcze podmienia te deskryptory i generalnie sprawa z jego puntu widzenia jest
 stosunkowo prosta
(jeszcze na marginesie musisz wziÄ…Ä‡ pod uwagÄ™ Å¼e na poczÄ…tku wczytujemy z stdin i
 na koÅ„cu piszemy do stdout)
teraz rodzic?
nie rozumiem tego.. skad sie nagle wezmÄ… i w dziecku i w ojcu po 2 pipe'y? ğŸ˜®
na poczatku robie sobie pipe(fd).. mam jakis pipe.. i teraz fork.. i w rodzicu i dziecku sa po dwa konce
ale skad nagle po 2 pipey?

najpierw tworzysz 2 pipe'y (tak naprawdÄ™ to jeden, ale to szczegÃ³Å‚ implementacyjny)
jak na rysunku xd
i jak robisz forka
to dziecko "dziedziczy" te pipe'y
i masz caÅ‚y czas dwa, i za kaÅ¼dÄ… komendÄ… jeden bÄ™dziesz zamykaÅ‚ caÅ‚kiem
i otwieraÅ‚ nowego pipe
ale nie rozumiem ;_; po co tworze dwa pipe'y ... ;_;

najpierw pierwsze dziecko:
stdin â†’ dziecko1 â†’ pipe1
potem drugie dziecko:
pipe1 â†’ dziecko2 â†’ pipe2
teraz musisz caÅ‚kowicie zamknÄ…Ä‡ pipe1 (bo jak nie zamkniesz to nie przeÅ›le ci siÄ™ eof)
a jak zamknÄ…Å‚eÅ› to nie moÅ¼esz go otworzyÄ‡, musisz stworzyÄ‡ nowego
wiÄ™c:
pipe2 â†’ dziecko3 â†’ pipe3
i teraz zamkniesz pipe2 i tworzysz pipe4


bo ogolnie.. dziecko z jakiegos pipe'a dostaje informacje .. i do jakiegos pisze, tak?
i stad dwa pipe'y?

taak! xd

onâ€¦ nie zniknÄ…Å‚â€¦ pipeline jest typem, konkretnie to jakiÅ› wskaÅºnik, nie pole w strukturzeâ€¦
 i masz tablicÄ™ tych pipelinÃ³w


 no po prostu: jeÅ¼eli jestem pierwszÄ… komendÄ… to nie otwieram pipe'a do odczytu,
  jeÅ¼eli jestem ostatniÄ… komendÄ… to nie odtwieram pipe'a do zapisuâ€¦
 gdzie przez "nie otwieram pipe'a"
 rozumiem: nie wykonujÄ™ tego dup2(â€¦)
 i to w sumie powinno starczyÄ‡â€¦
 bo wszystko zamykaszâ€¦

a tu juÅ¼ nie ma wielkiej filozofii, czyste klepactwo w c xd
ze dwa ifyâ€¦
bÄ™dzie czytaÅ‚o z stdin jak nie przyczepisz pipe'a

mhm.. w tej funkcji comand , tak? gdzie forkuje itp ?

czyli nie zrobisz tego dup

teraz masz do wyboru dwie rzeczyâ€¦
1) poczÄ…tek i koniec - najpierw wczytujesz z stdin i na koÅ„cu piszesz do stdout nie do pipe'a
i na koÅ„cu zamykasz to co ci jeszcze zostaÅ‚o do zamkniÄ™ciaâ€¦ wszystko co siÄ™ da xd
2) zrobiÄ‡ to w pÄ™tliâ€¦ pipe'y polecam otwieraÄ‡ jeszcze w execute, przed tÄ… najbardziej wewnÄ™trznÄ… pÄ™tlÄ…â€¦
i w tej wewnÄ™trznej pÄ™tli, w tym else bÄ™dziesz zamykaÅ‚ poprzedniego i otwieraÅ‚ nowego
i jak to zrobisz to bÄ™dzie wszystko ^^

polecam zaczÄ…Ä‡ od 2â€¦
"w tym else" noo w sumie po wywoÅ‚aniu command u cbâ€¦ no gdzieÅ› wtedy ğŸ˜›
